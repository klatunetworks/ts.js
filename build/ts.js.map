{
  "version": 3,
  "sources": ["../ts.coffee"],
  "sourcesContent": ["(function() {\n  /*\n  ts.js - version 0.9.2\n\n  Copyright 2012 Dan Simpson, Mike Countis\n\n  MIT License: http://opensource.org/licenses/MIT\n  */\n  var MultiTimeseries, NumericTimeseries, Timeseries, TimeseriesFactory, factory;\n\n  TimeseriesFactory = class TimeseriesFactory {\n    constructor() {}\n\n    validate(data) {\n      if (data.length === 0) {\n        throw \"Timeseries expects an array of data.\";\n      }\n      if (data[0].length !== 2) {\n        throw \"Timeseries expects input like [[timestamp, value]...]\";\n      }\n      if (typeof data[0][0] !== \"number\") {\n        throw \"Timeseries expects timestamps; eg: [[timestamp, value]...]\";\n      }\n    }\n\n    // Convert a 1-dimensional array to a 2d arry with\n    // timestamps and values\n    // +data+ the array of objects to timestamp\n    // +start+ the start time (defaults to now)\n    // +step+ the number of milliseconds between each\n    timestamp(data, start = new Date().getTime(), step = 60000) {\n      var i, j, len, r, v;\n      i = 0;\n      r = [];\n      for (j = 0, len = data.length; j < len; j++) {\n        v = data[j];\n        r.push([start + (i++ * step), v]);\n      }\n      return r;\n    }\n\n    // Wrap 2d array of timeseries data in a Timeseries object\n    wrap(data, validate = true) {\n      if (validate) {\n        this.validate(data);\n      }\n      return new Timeseries(data);\n    }\n\n    // Create a NumericTimeseries object, capable basic plotting, etc\n    numeric(data, validate = true) {\n      if (validate) {\n        this.validate(data);\n        if (typeof data[0][1] !== \"number\") {\n          throw \"NumericTimeseries expects timestamps and numbers; eg: [[timestamp, number]...]\";\n        }\n      }\n      return new NumericTimeseries(data);\n    }\n\n    // create a MultiTimeseries object with the data\n    multi(data, validate = true) {\n      if (validate) {\n        this.validate(data);\n      }\n      return new MultiTimeseries(data);\n    }\n\n    // Guess what kind of data we are working with\n    build(data) {\n      this.validate(data);\n      if (typeof data[0][1] === \"number\") {\n        return this.numeric(data);\n      } else if (typeof data[0][1] === \"string\") {\n        return this.wrap(data);\n      } else {\n        return this.multi(data);\n      }\n    }\n\n  };\n\n  factory = new TimeseriesFactory();\n\n  /*\n   *\n   *\n   */\n  Timeseries = class Timeseries {\n    constructor(data1) {\n      this.data = data1;\n      this.squelched = false;\n      this.listeners = [];\n      this.init_listeners = [];\n      this.timeframe = null;\n    }\n\n    // the number of samples\n    size() {\n      return this.data.length;\n    }\n\n    empty() {\n      return this.data.length === 0;\n    }\n\n    // the number of samples\n    length() {\n      return this.data.length;\n    }\n\n    // the number of samples\n    count() {\n      return this.data.length;\n    }\n\n    // given a range of timestamps, find the nearest indices\n    // for slicing\n    slice_indices(t1, t2) {\n      var idx1, idx2;\n      idx1 = this.nearest(t1);\n      idx2 = this.nearest(t2);\n      // don't include a value not in range\n      if (this.time(idx1) < t1) {\n        ++idx1;\n      }\n      // slice goes up to, but doesn't include, so only\n      // add if the nearest is less than\n      if (this.time(idx2) < t2) {\n        ++idx2;\n      }\n      return [idx1, idx2];\n    }\n\n    // limit the total duration, or time frame of the\n    // time series\n    limit(duration) {\n      this.timeframe = duration;\n      return this;\n    }\n\n    // If timeframe is set, trim head of series\n    behead() {\n      var count, head, min;\n      if (this.timeframe === null) {\n        return [];\n      }\n      min = this.end() - this.timeframe;\n      count = 0;\n      while (this.data[count][0] < min) {\n        count++;\n      }\n      head = this.data.slice(0, count);\n      this.data = this.data.slice(count);\n      return head;\n    }\n\n    // the first sample\n    first() {\n      return this.data[0];\n    }\n\n    // the last sample\n    last() {\n      return this.data[this.size() - 1];\n    }\n\n    // get the sample at index idx\n    sample(idx) {\n      return this.data[idx];\n    }\n\n    // get the time at index idx\n    time(idx) {\n      return this.data[idx][0];\n    }\n\n    // get the value at index idx\n    value(idx) {\n      return this.data[idx][1];\n    }\n\n    // time domain (earliest, latest)\n    domain() {\n      return [this.first()[0], this.last()[0]];\n    }\n\n    // append another timerseries item\n    append(t, v) {\n      if (this.empty()) {\n        this.data.push([t, v]);\n        return;\n      }\n      if (t < this.end()) {\n        throw \"Can't append sample with past timestamp\";\n      }\n      this.data.push([t, v]);\n      this.behead();\n      return this.notify();\n    }\n\n    // see append\n    push(t, v) {\n      return this.append(t, v);\n    }\n\n    // see append\n    add(t, v) {\n      return this.append(t, v);\n    }\n\n    // notify listeners of a change\n    notify() {\n      var j, k, len, len1, listener, ref, ref1, results;\n      if (this.squelched) {\n        return;\n      }\n      if (this.size() === 2) {\n        ref = this.init_listeners;\n        for (j = 0, len = ref.length; j < len; j++) {\n          listener = ref[j];\n          listener();\n        }\n      }\n      ref1 = this.listeners;\n      results = [];\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        listener = ref1[k];\n        results.push(listener());\n      }\n      return results;\n    }\n\n    listen(fn) {\n      return this.listeners.push(fn);\n    }\n\n    on_init(fn) {\n      return this.init_listeners.push(fn);\n    }\n\n    // values as 1d array\n    values() {\n      var j, len, r, ref, t, v;\n      r = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        r.push(v);\n      }\n      return r;\n    }\n\n    // The total duration of the series\n    duration() {\n      return this.end() - this.start();\n    }\n\n    // The start time\n    start() {\n      return this.first()[0];\n    }\n\n    // The end time\n    end() {\n      return this.last()[0];\n    }\n\n    // scan timeseries and get the range of events between\n    // time nearest values of t1 and time t2\n    scan(t1, t2) {\n      var idx1, idx2;\n      [idx1, idx2] = this.slice_indices(t1, t2);\n      return new this.constructor(this.data.slice(idx1, idx2));\n    }\n\n    // filter out items and return new\n    // timeseries\n    filter(fn) {\n      var j, len, r, ref, tv;\n      r = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        tv = ref[j];\n        if (fn(tv[0], tv[1])) {\n          r.push(tv);\n        }\n      }\n      return new this.constructor(r);\n    }\n\n    // split the series into two series\n    split(time) {\n      var j, len, r1, r2, ref, tv;\n      r1 = [];\n      r2 = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        tv = ref[j];\n        if (tv[0] <= time) {\n          r1.push(tv);\n        } else {\n          r2.push(tv);\n        }\n      }\n      return [new this.constructor(r1), new this.constructor(r2)];\n    }\n\n    // Break data into windows of a given duration, returning\n    // a timeseries of timeseries objects\n    partition(duration) {\n      var chunk, j, len, ref, result, t, time, v;\n      time = this.start() - Math.abs(this.start() % duration);\n      result = [];\n      chunk = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        while (t - time >= duration) {\n          result.push([time, factory.build(chunk)]);\n          chunk = [];\n          time += duration;\n        }\n        chunk.push([t, v]);\n      }\n      if (chunk.length > 0) {\n        result.push([time, factory.build(chunk)]);\n      }\n      // TODO: bind to parent and emit?\n      return factory.wrap(result, false);\n    }\n\n    // map each series tuple to a new tuple via function call\n    map(fn) {\n      var j, len, r, ref, tv;\n      r = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        tv = ref[j];\n        r.push(fn(tv[0], tv[1]));\n      }\n      return factory.build(r);\n    }\n\n    // partition by duration and fold each partitioned sub-series\n    // into a new value\n    pfold(duration, fn) {\n      return this.partition(duration).map(fn);\n    }\n\n    // timestamps as 1d array\n    timestamps() {\n      var j, len, r, ref, t, v;\n      r = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        r.push(t);\n      }\n      return r;\n    }\n\n    // finds the nearest index in the domain using\n    // a binary search\n    // +timestamp+ the time to search for\n    // +lbound+ if true, the index will always justify to the past\n    nearest(timestamp, lbound = false) {\n      var idx;\n      if (timestamp <= this.start()) {\n        return 0;\n      }\n      if (timestamp >= this.end()) {\n        return this.size() - 1;\n      }\n      idx = this.bsearch(timestamp, 0, this.size() - 1);\n      if (lbound && this.time(idx) > timestamp) {\n        idx = Math.max(0, idx - 1);\n      }\n      return idx;\n    }\n\n    // binary search for a timestamp with some fuzzy\n    // matching if we don't get the exact idx\n    bsearch(timestamp, idx1, idx2) {\n      var diff1, diff2, mid;\n      mid = Math.floor((idx2 - idx1) / 2.0) + idx1;\n      if (idx1 === mid) {\n        diff1 = Math.abs(this.time(idx1) - timestamp);\n        diff2 = Math.abs(this.time(idx2) - timestamp);\n        if (diff2 > diff1) {\n          return idx1;\n        } else {\n          return idx2;\n        }\n      } else if (timestamp < this.time(mid)) {\n        return this.bsearch(timestamp, idx1, mid);\n      } else if (timestamp > this.time(mid)) {\n        return this.bsearch(timestamp, mid, idx2);\n      } else {\n        return mid;\n      }\n    }\n\n    // report\n    toString() {\n      return `Timeseries\nitems   : ${this.size()}\ndomain  : ${this.domain()}`;\n    }\n\n  };\n\n  /*\n   * NumbericTimeseries class\n   *\n   * A class for wrapping timed values\n   *\n   * data: a 2d array containing\n   *\n   */\n  NumericTimeseries = class NumericTimeseries extends Timeseries {\n    constructor(data) {\n      super(data);\n    }\n\n    statistics() {\n      var j, len, max, min, ref, sum, t, v;\n      if (this._stats) {\n        return this._stats;\n      }\n      sum = 0.0;\n      min = 2e308;\n      max = -2e308;\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        sum += v;\n        if (v > max) {\n          max = v;\n        }\n        if (v < min) {\n          min = v;\n        }\n      }\n      return this._stats = {\n        sum: sum,\n        min: min,\n        max: max\n      };\n    }\n\n    // shift the first item off the list and update stats\n    behead() {\n      var head, j, len, t, v;\n      head = super.behead();\n      if (head.length === 0 || !this._stats) {\n        return;\n      }\n      for (j = 0, len = head.length; j < len; j++) {\n        [t, v] = head[j];\n        this._stats.sum -= v;\n        // if we have the min, or max... just purge the cache\n        if (v === this._stats.min || v === this._stats.max) {\n          this._stats = false;\n          return;\n        }\n      }\n    }\n\n    // append another timerseries item, updating calcs\n    append(t, v) {\n      if (t < this.end()) {\n        throw \"Can't append sample with past timestamp\";\n      }\n      if (this._stats) {\n        this._stats.sum += v;\n        this._stats.min = Math.min(this._stats.min, v);\n        this._stats.max = Math.max(this._stats.max, v);\n      }\n      return super.append(t, v);\n    }\n\n    // the sum of all values\n    sum() {\n      return this.statistics().sum;\n    }\n\n    // the sum of squares\n    sumsq() {\n      var j, len, m, n, r, ref, t, v;\n      m = this.mean();\n      r = 0;\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        n = v - m;\n        r += n * n;\n      }\n      return r;\n    }\n\n    // variance of the values\n    variance() {\n      return this.sumsq() / (this.size() - 1);\n    }\n\n    // standard deviation of the values\n    stddev() {\n      return Math.sqrt(this.variance());\n    }\n\n    // mean of value\n    mean() {\n      return this.sum() / this.size();\n    }\n\n    // value range (min, max)\n    range() {\n      return [this.min(), this.max()];\n    }\n\n    // value range (min, max)\n    span() {\n      return this.max() - this.min();\n    }\n\n    // minimum of value\n    min() {\n      return this.statistics().min;\n    }\n\n    // maximum of values\n    max() {\n      return this.statistics().max;\n    }\n\n    // values as 1d array\n    values() {\n      var j, len, r, ref, t, v;\n      r = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        r.push(v);\n      }\n      return r;\n    }\n\n    // return a sorted set of values\n    valuesSorted() {\n      if (this._valuesSorted) {\n        return this._valuesSorted;\n      }\n      return this._valuesSorted = this.values().sort(function(a, b) {\n        return a - b;\n      });\n    }\n\n    quartiles() {\n      return {\n        min: this.min(),\n        p25: this.p25th(),\n        mid: this.median(),\n        p75: this.p75th(),\n        max: this.max()\n      };\n    }\n\n    p25th() {\n      return this.percentile(0.25);\n    }\n\n    p75th() {\n      return this.percentile(0.75);\n    }\n\n    median() {\n      return this.percentile(0.5);\n    }\n\n    percentile(p) {\n      var idx;\n      idx = Math.floor(this.size() * p);\n      if (this.size() % 2) {\n        return this.valuesSorted()[idx];\n      } else {\n        return (this.valuesSorted()[idx - 1] + this.valuesSorted()[idx]) / 2;\n      }\n    }\n\n    // normalized values as 1d array\n    norms() {\n      var j, len, r, ref, t, v;\n      r = [];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        [t, v] = ref[j];\n        r.push((v - this.mean()) / this.stddev());\n      }\n      return r;\n    }\n\n    // simplifies the data set based on a percentage change\n    // If the range is great, yet the standard deviation is low\n    // then we will not reduce much\n    // Todo: Douglas Peuker\n    simplify(threshold = 0.1) {\n      var j, last, len, r, range, ref, tv;\n      last = this.first();\n      range = this.max() - this.min();\n      r = [last];\n      ref = this.data;\n      for (j = 0, len = ref.length; j < len; j++) {\n        tv = ref[j];\n        if (((Math.abs(tv[1] - last[1])) / range) > threshold) {\n          if (last[0] !== r[r.length - 1][0]) {\n            r.push(last);\n          }\n          r.push(tv);\n        }\n        last = tv;\n      }\n      if (last[0] !== r[r.length - 1][0]) {\n        r.push(last);\n      }\n      return factory.build(r);\n    }\n\n    // Find the best fit match for the pattern in the\n    // time series.  The data is first normalized\n    match(pattern) {\n      var best, distance, i, idx, j, query, ref, source;\n      if (!(pattern instanceof Timeseries)) {\n        throw \"Must match against a Timeseries object\";\n      }\n      // best fit\n      best = 999999999;\n      idx = -1;\n      query = pattern.norms();\n      source = this.norms();\n      if (!(query.length <= source.length)) {\n        throw \"Query length exceeds source length\";\n      }\n      for (i = j = 0, ref = source.length - query.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n        distance = this._distance(query, source.slice(i, +(i + query.length) + 1 || 9e9));\n        if (distance < best) {\n          best = distance;\n          idx = i;\n        }\n      }\n      return idx;\n    }\n\n    // Euclidean distance function for one timeseries on another\n    // used for pattern searching\n    _distance(ts1, ts2) {\n      var diff, i, j, ref, sum;\n      if (ts1.length !== ts2.length) {\n        throw \"Array lengths must match for distance\";\n      }\n      sum = 0.0;\n      for (i = j = 0, ref = ts1.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n        diff = ts2[i] - ts1[i];\n        sum += diff * diff;\n      }\n      return Math.sqrt(sum);\n    }\n\n    // report\n    toString() {\n      return `Timeseries\nitems   : ${this.size()}\nmean    : ${this.mean()}\nstddev  : ${this.stddev()}\ndomain  : ${this.domain()}\nrange   : ${this.range()}\nvariance: ${this.variance()}`;\n    }\n\n  };\n\n  /*\n  MultiTimeseries class\n\n  A wrapper of many timeseries which share a timeline.\n\n  The underlying structure ends up being a simple spanning tree, which you can\n  query by path or name.\n\n  Example... one of your data values looks like this:\n  data = [timestamp, {\n    dan: {\n      drinks: 2,\n      calories: 160\n    },\n    mike: {\n      drinks: 1,\n      calories: -1\n    }\n  }, ...]\n\n  var tree = $ts.multi(data)\n  tree.series(\"dan/drinks\").max(); // -> 2\n  tree.series(\"dan/calories\").max(); // -> 160\n  tree.series(\"mike/drinks\").max(); // -> 1\n  tree.series(\"mike/calories\").max(); // -> -1\n\n  tree.series(\"dan\") -> MultiTimeseries\n\n  */\n  MultiTimeseries = class MultiTimeseries extends Timeseries {\n    constructor(data) {\n      var j, key, len, point, ref, ref1, ref2, value;\n      super(data);\n      // At this point we should have a time series\n      // with standard object values (key, value).\n      // Take those values and split them into singular ts\n      this.lookup = {};\n      this.attrs = [];\n      ref = this.data;\n      // add items to each sub array\n      for (j = 0, len = ref.length; j < len; j++) {\n        point = ref[j];\n        ref1 = point[1];\n        for (key in ref1) {\n          value = ref1[key];\n          if (!this.lookup.hasOwnProperty(key)) {\n            this.lookup[key] = [];\n            this.attrs.push(key);\n          }\n          this.lookup[key].push([point[0], value]);\n        }\n      }\n      ref2 = this.lookup;\n      // Convert array to ts oject, nested if need be\n      for (key in ref2) {\n        value = ref2[key];\n        this.lookup[key] = factory.build(this.lookup[key]);\n      }\n    }\n\n    // find a series by name or path\n    // eg: mts.series(\"hits\")\n    // eg: mts.series(\"hostname.com/hits\")\n    series(name) {\n      var head, parts;\n      if (name[0] === \"/\") {\n        return this.series(name.substr(1));\n      }\n      if (name.indexOf(\"/\") > 0) {\n        parts = name.split(\"/\");\n        head = parts.shift();\n        if (!this.lookup[head]) {\n          return null;\n        }\n        return this.lookup[head].series(parts.join(\"/\"));\n      }\n      // base case...\n      if (!this.lookup[name]) {\n        return null;\n      }\n      return this.lookup[name];\n    }\n\n    get(name) {\n      return this.series(name);\n    }\n\n    limit(duration) {\n      var name, ref, results, ts;\n      super.limit(duration);\n      ref = this.lookup;\n      results = [];\n      for (name in ref) {\n        ts = ref[name];\n        results.push(ts.limit(duration));\n      }\n      return results;\n    }\n\n    append(t, v) {\n      var key, value;\n      for (key in v) {\n        value = v[key];\n        if (this.lookup.hasOwnProperty(key)) {\n          this.lookup[key].append(t, value);\n        } else {\n          this.lookup[key] = factory.build([[t, value]]);\n          this.attrs.push(key);\n        }\n      }\n      return super.append(t, v);\n    }\n\n    attr(name) {\n      return this.series(name);\n    }\n\n    serieses() {\n      return this.attrs;\n    }\n\n    // minimum of value\n    min() {\n      var key, mins, ref, series;\n      mins = [];\n      ref = this.lookup;\n      for (key in ref) {\n        series = ref[key];\n        if (series.min) {\n          mins.push(series.min());\n        }\n      }\n      return Math.min.apply(Math, mins);\n    }\n\n    // maximum of values\n    max() {\n      var key, maxes, ref, series;\n      maxes = [];\n      ref = this.lookup;\n      for (key in ref) {\n        series = ref[key];\n        if (series.max) {\n          maxes.push(series.max());\n        }\n      }\n      return Math.max.apply(Math, maxes);\n    }\n\n    // determine if a series exists by name\n    exists(name) {\n      return this.series(name) !== null;\n    }\n\n  };\n\n  module.exports = factory;\n\n}).call(this);\n"],
  "mappings": "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",
  "names": []
}

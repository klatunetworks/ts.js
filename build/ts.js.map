{
  "version": 3,
  "sources": ["../ts.coffee"],
  "sourcesContent": ["var MultiTimeseries, NumericTimeseries, Timeseries, TimeseriesFactory, factory;\n\nTimeseriesFactory = class TimeseriesFactory {\n  constructor() {}\n\n  validate(data) {\n    if (data.length === 0) {\n      throw \"Timeseries expects an array of data.\";\n    }\n    if (data[0].length !== 2) {\n      throw \"Timeseries expects input like [[timestamp, value]...]\";\n    }\n    if (typeof data[0][0] !== \"number\") {\n      throw \"Timeseries expects timestamps; eg: [[timestamp, value]...]\";\n    }\n  }\n\n  // Convert a 1-dimensional array to a 2d arry with\n  // timestamps and values\n  // +data+ the array of objects to timestamp\n  // +start+ the start time (defaults to now)\n  // +step+ the number of milliseconds between each\n  timestamp(data, start = new Date().getTime(), step = 60000) {\n    var i, j, len, r, v;\n    i = 0;\n    r = [];\n    for (j = 0, len = data.length; j < len; j++) {\n      v = data[j];\n      r.push([start + (i++ * step), v]);\n    }\n    return r;\n  }\n\n  // Wrap 2d array of timeseries data in a Timeseries object\n  wrap(data, validate = true) {\n    if (validate) {\n      this.validate(data);\n    }\n    return new Timeseries(data);\n  }\n\n  // Create a NumericTimeseries object, capable basic plotting, etc\n  numeric(data, validate = true) {\n    if (validate) {\n      this.validate(data);\n      if (typeof data[0][1] !== \"number\") {\n        throw \"NumericTimeseries expects timestamps and numbers; eg: [[timestamp, number]...]\";\n      }\n    }\n    return new NumericTimeseries(data);\n  }\n\n  // create a MultiTimeseries object with the data\n  multi(data, validate = true) {\n    if (validate) {\n      this.validate(data);\n    }\n    return new MultiTimeseries(data);\n  }\n\n  // Guess what kind of data we are working with\n  build(data) {\n    this.validate(data);\n    if (typeof data[0][1] === \"number\") {\n      return this.numeric(data);\n    } else if (typeof data[0][1] === \"string\") {\n      return this.wrap(data);\n    } else {\n      return this.multi(data);\n    }\n  }\n\n};\n\nfactory = new TimeseriesFactory();\n\n/*\n *\n *\n */\nTimeseries = class Timeseries {\n  constructor(data1) {\n    this.data = data1;\n    this.squelched = false;\n    this.listeners = [];\n    this.init_listeners = [];\n    this.timeframe = null;\n  }\n\n  // the number of samples\n  size() {\n    return this.data.length;\n  }\n\n  empty() {\n    return this.data.length === 0;\n  }\n\n  // the number of samples\n  length() {\n    return this.data.length;\n  }\n\n  // the number of samples\n  count() {\n    return this.data.length;\n  }\n\n  // given a range of timestamps, find the nearest indices\n  // for slicing\n  slice_indices(t1, t2) {\n    var idx1, idx2;\n    idx1 = this.nearest(t1);\n    idx2 = this.nearest(t2);\n    // don't include a value not in range\n    if (this.time(idx1) < t1) {\n      ++idx1;\n    }\n    // slice goes up to, but doesn't include, so only\n    // add if the nearest is less than\n    if (this.time(idx2) < t2) {\n      ++idx2;\n    }\n    return [idx1, idx2];\n  }\n\n  // limit the total duration, or time frame of the\n  // time series\n  limit(duration) {\n    this.timeframe = duration;\n    return this;\n  }\n\n  // If timeframe is set, trim head of series\n  behead() {\n    var count, head, min;\n    if (this.timeframe === null) {\n      return [];\n    }\n    min = this.end() - this.timeframe;\n    count = 0;\n    while (this.data[count][0] < min) {\n      count++;\n    }\n    head = this.data.slice(0, count);\n    this.data = this.data.slice(count);\n    return head;\n  }\n\n  // the first sample\n  first() {\n    return this.data[0];\n  }\n\n  // the last sample\n  last() {\n    return this.data[this.size() - 1];\n  }\n\n  // get the sample at index idx\n  sample(idx) {\n    return this.data[idx];\n  }\n\n  // get the time at index idx\n  time(idx) {\n    return this.data[idx][0];\n  }\n\n  // get the value at index idx\n  value(idx) {\n    return this.data[idx][1];\n  }\n\n  // time domain (earliest, latest)\n  domain() {\n    return [this.first()[0], this.last()[0]];\n  }\n\n  // append another timerseries item\n  append(t, v) {\n    if (this.empty()) {\n      this.data.push([t, v]);\n      return;\n    }\n    if (t < this.end()) {\n      throw \"Can't append sample with past timestamp\";\n    }\n    this.data.push([t, v]);\n    this.behead();\n    return this.notify();\n  }\n\n  // see append\n  push(t, v) {\n    return this.append(t, v);\n  }\n\n  // see append\n  add(t, v) {\n    return this.append(t, v);\n  }\n\n  // notify listeners of a change\n  notify() {\n    var j, k, len, len1, listener, ref, ref1, results;\n    if (this.squelched) {\n      return;\n    }\n    if (this.size() === 2) {\n      ref = this.init_listeners;\n      for (j = 0, len = ref.length; j < len; j++) {\n        listener = ref[j];\n        listener();\n      }\n    }\n    ref1 = this.listeners;\n    results = [];\n    for (k = 0, len1 = ref1.length; k < len1; k++) {\n      listener = ref1[k];\n      results.push(listener());\n    }\n    return results;\n  }\n\n  listen(fn) {\n    return this.listeners.push(fn);\n  }\n\n  on_init(fn) {\n    return this.init_listeners.push(fn);\n  }\n\n  // values as 1d array\n  values() {\n    var j, len, r, ref, t, v;\n    r = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      r.push(v);\n    }\n    return r;\n  }\n\n  // The total duration of the series\n  duration() {\n    return this.end() - this.start();\n  }\n\n  // The start time\n  start() {\n    return this.first()[0];\n  }\n\n  // The end time\n  end() {\n    return this.last()[0];\n  }\n\n  // scan timeseries and get the range of events between\n  // time nearest values of t1 and time t2\n  scan(t1, t2) {\n    var idx1, idx2;\n    [idx1, idx2] = this.slice_indices(t1, t2);\n    return new this.constructor(this.data.slice(idx1, idx2));\n  }\n\n  // filter out items and return new\n  // timeseries\n  filter(fn) {\n    var j, len, r, ref, tv;\n    r = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      tv = ref[j];\n      if (fn(tv[0], tv[1])) {\n        r.push(tv);\n      }\n    }\n    return new this.constructor(r);\n  }\n\n  // split the series into two series\n  split(time) {\n    var j, len, r1, r2, ref, tv;\n    r1 = [];\n    r2 = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      tv = ref[j];\n      if (tv[0] <= time) {\n        r1.push(tv);\n      } else {\n        r2.push(tv);\n      }\n    }\n    return [new this.constructor(r1), new this.constructor(r2)];\n  }\n\n  // Break data into windows of a given duration, returning\n  // a timeseries of timeseries objects\n  partition(duration) {\n    var chunk, j, len, ref, result, t, time, v;\n    time = this.start() - Math.abs(this.start() % duration);\n    result = [];\n    chunk = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      while (t - time >= duration) {\n        result.push([time, factory.build(chunk)]);\n        chunk = [];\n        time += duration;\n      }\n      chunk.push([t, v]);\n    }\n    if (chunk.length > 0) {\n      result.push([time, factory.build(chunk)]);\n    }\n    // TODO: bind to parent and emit?\n    return factory.wrap(result, false);\n  }\n\n  // map each series tuple to a new tuple via function call\n  map(fn) {\n    var j, len, r, ref, tv;\n    r = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      tv = ref[j];\n      r.push(fn(tv[0], tv[1]));\n    }\n    return factory.build(r);\n  }\n\n  // partition by duration and fold each partitioned sub-series\n  // into a new value\n  pfold(duration, fn) {\n    return this.partition(duration).map(fn);\n  }\n\n  // timestamps as 1d array\n  timestamps() {\n    var j, len, r, ref, t, v;\n    r = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      r.push(t);\n    }\n    return r;\n  }\n\n  // finds the nearest index in the domain using\n  // a binary search\n  // +timestamp+ the time to search for\n  // +lbound+ if true, the index will always justify to the past\n  nearest(timestamp, lbound = false) {\n    var idx;\n    if (timestamp <= this.start()) {\n      return 0;\n    }\n    if (timestamp >= this.end()) {\n      return this.size() - 1;\n    }\n    idx = this.bsearch(timestamp, 0, this.size() - 1);\n    if (lbound && this.time(idx) > timestamp) {\n      idx = Math.max(0, idx - 1);\n    }\n    return idx;\n  }\n\n  // binary search for a timestamp with some fuzzy\n  // matching if we don't get the exact idx\n  bsearch(timestamp, idx1, idx2) {\n    var diff1, diff2, mid;\n    mid = Math.floor((idx2 - idx1) / 2.0) + idx1;\n    if (idx1 === mid) {\n      diff1 = Math.abs(this.time(idx1) - timestamp);\n      diff2 = Math.abs(this.time(idx2) - timestamp);\n      if (diff2 > diff1) {\n        return idx1;\n      } else {\n        return idx2;\n      }\n    } else if (timestamp < this.time(mid)) {\n      return this.bsearch(timestamp, idx1, mid);\n    } else if (timestamp > this.time(mid)) {\n      return this.bsearch(timestamp, mid, idx2);\n    } else {\n      return mid;\n    }\n  }\n\n  // report\n  toString() {\n    return `Timeseries\nitems   : ${this.size()}\ndomain  : ${this.domain()}`;\n  }\n\n};\n\n/*\n * NumbericTimeseries class\n *\n * A class for wrapping timed values\n *\n * data: a 2d array containing\n *\n */\nNumericTimeseries = class NumericTimeseries extends Timeseries {\n  constructor(data) {\n    super(data);\n  }\n\n  statistics() {\n    var j, len, max, min, ref, sum, t, v;\n    if (this._stats) {\n      return this._stats;\n    }\n    sum = 0.0;\n    min = 2e308;\n    max = -2e308;\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      sum += v;\n      if (v > max) {\n        max = v;\n      }\n      if (v < min) {\n        min = v;\n      }\n    }\n    return this._stats = {\n      sum: sum,\n      min: min,\n      max: max\n    };\n  }\n\n  // shift the first item off the list and update stats\n  behead() {\n    var head, j, len, t, v;\n    head = super.behead();\n    if (head.length === 0 || !this._stats) {\n      return;\n    }\n    for (j = 0, len = head.length; j < len; j++) {\n      [t, v] = head[j];\n      this._stats.sum -= v;\n      // if we have the min, or max... just purge the cache\n      if (v === this._stats.min || v === this._stats.max) {\n        this._stats = false;\n        return;\n      }\n    }\n  }\n\n  // append another timerseries item, updating calcs\n  append(t, v) {\n    if (t < this.end()) {\n      throw \"Can't append sample with past timestamp\";\n    }\n    if (this._stats) {\n      this._stats.sum += v;\n      this._stats.min = Math.min(this._stats.min, v);\n      this._stats.max = Math.max(this._stats.max, v);\n    }\n    return super.append(t, v);\n  }\n\n  // the sum of all values\n  sum() {\n    return this.statistics().sum;\n  }\n\n  // the sum of squares\n  sumsq() {\n    var j, len, m, n, r, ref, t, v;\n    m = this.mean();\n    r = 0;\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      n = v - m;\n      r += n * n;\n    }\n    return r;\n  }\n\n  // variance of the values\n  variance() {\n    return this.sumsq() / (this.size() - 1);\n  }\n\n  // standard deviation of the values\n  stddev() {\n    return Math.sqrt(this.variance());\n  }\n\n  // mean of value\n  mean() {\n    return this.sum() / this.size();\n  }\n\n  // value range (min, max)\n  range() {\n    return [this.min(), this.max()];\n  }\n\n  // value range (min, max)\n  span() {\n    return this.max() - this.min();\n  }\n\n  // minimum of value\n  min() {\n    return this.statistics().min;\n  }\n\n  // maximum of values\n  max() {\n    return this.statistics().max;\n  }\n\n  // values as 1d array\n  values() {\n    var j, len, r, ref, t, v;\n    r = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      r.push(v);\n    }\n    return r;\n  }\n\n  // return a sorted set of values\n  valuesSorted() {\n    if (this._valuesSorted) {\n      return this._valuesSorted;\n    }\n    return this._valuesSorted = this.values().sort(function(a, b) {\n      return a - b;\n    });\n  }\n\n  quartiles() {\n    return {\n      min: this.min(),\n      p25: this.p25th(),\n      mid: this.median(),\n      p75: this.p75th(),\n      max: this.max()\n    };\n  }\n\n  p25th() {\n    return this.percentile(0.25);\n  }\n\n  p75th() {\n    return this.percentile(0.75);\n  }\n\n  median() {\n    return this.percentile(0.5);\n  }\n\n  percentile(p) {\n    var idx;\n    idx = Math.floor(this.size() * p);\n    if (this.size() % 2) {\n      return this.valuesSorted()[idx];\n    } else {\n      return (this.valuesSorted()[idx - 1] + this.valuesSorted()[idx]) / 2;\n    }\n  }\n\n  // normalized values as 1d array\n  norms() {\n    var j, len, r, ref, t, v;\n    r = [];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      [t, v] = ref[j];\n      r.push((v - this.mean()) / this.stddev());\n    }\n    return r;\n  }\n\n  // simplifies the data set based on a percentage change\n  // If the range is great, yet the standard deviation is low\n  // then we will not reduce much\n  // Todo: Douglas Peuker\n  simplify(threshold = 0.1) {\n    var j, last, len, r, range, ref, tv;\n    last = this.first();\n    range = this.max() - this.min();\n    r = [last];\n    ref = this.data;\n    for (j = 0, len = ref.length; j < len; j++) {\n      tv = ref[j];\n      if (((Math.abs(tv[1] - last[1])) / range) > threshold) {\n        if (last[0] !== r[r.length - 1][0]) {\n          r.push(last);\n        }\n        r.push(tv);\n      }\n      last = tv;\n    }\n    if (last[0] !== r[r.length - 1][0]) {\n      r.push(last);\n    }\n    return factory.build(r);\n  }\n\n  // Find the best fit match for the pattern in the\n  // time series.  The data is first normalized\n  match(pattern) {\n    var best, distance, i, idx, j, query, ref, source;\n    if (!(pattern instanceof Timeseries)) {\n      throw \"Must match against a Timeseries object\";\n    }\n    // best fit\n    best = 999999999;\n    idx = -1;\n    query = pattern.norms();\n    source = this.norms();\n    if (!(query.length <= source.length)) {\n      throw \"Query length exceeds source length\";\n    }\n    for (i = j = 0, ref = source.length - query.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n      distance = this._distance(query, source.slice(i, +(i + query.length) + 1 || 9e9));\n      if (distance < best) {\n        best = distance;\n        idx = i;\n      }\n    }\n    return idx;\n  }\n\n  // Euclidean distance function for one timeseries on another\n  // used for pattern searching\n  _distance(ts1, ts2) {\n    var diff, i, j, ref, sum;\n    if (ts1.length !== ts2.length) {\n      throw \"Array lengths must match for distance\";\n    }\n    sum = 0.0;\n    for (i = j = 0, ref = ts1.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n      diff = ts2[i] - ts1[i];\n      sum += diff * diff;\n    }\n    return Math.sqrt(sum);\n  }\n\n  // report\n  toString() {\n    return `Timeseries\nitems   : ${this.size()}\nmean    : ${this.mean()}\nstddev  : ${this.stddev()}\ndomain  : ${this.domain()}\nrange   : ${this.range()}\nvariance: ${this.variance()}`;\n  }\n\n};\n\n/*\nMultiTimeseries class\n\nA wrapper of many timeseries which share a timeline.\n\nThe underlying structure ends up being a simple spanning tree, which you can\nquery by path or name.\n\nExample... one of your data values looks like this:\ndata = [timestamp, {\n  dan: {\n    drinks: 2,\n    calories: 160\n  },\n  mike: {\n    drinks: 1,\n    calories: -1\n  }\n}, ...]\n\nvar tree = $ts.multi(data)\ntree.series(\"dan/drinks\").max(); // -> 2\ntree.series(\"dan/calories\").max(); // -> 160\ntree.series(\"mike/drinks\").max(); // -> 1\ntree.series(\"mike/calories\").max(); // -> -1\n\ntree.series(\"dan\") -> MultiTimeseries\n\n*/\nMultiTimeseries = class MultiTimeseries extends Timeseries {\n  constructor(data) {\n    var j, key, len, point, ref, ref1, ref2, value;\n    super(data);\n    // At this point we should have a time series\n    // with standard object values (key, value).\n    // Take those values and split them into singular ts\n    this.lookup = {};\n    this.attrs = [];\n    ref = this.data;\n    // add items to each sub array\n    for (j = 0, len = ref.length; j < len; j++) {\n      point = ref[j];\n      ref1 = point[1];\n      for (key in ref1) {\n        value = ref1[key];\n        if (!this.lookup.hasOwnProperty(key)) {\n          this.lookup[key] = [];\n          this.attrs.push(key);\n        }\n        this.lookup[key].push([point[0], value]);\n      }\n    }\n    ref2 = this.lookup;\n    // Convert array to ts oject, nested if need be\n    for (key in ref2) {\n      value = ref2[key];\n      this.lookup[key] = factory.build(this.lookup[key]);\n    }\n  }\n\n  // find a series by name or path\n  // eg: mts.series(\"hits\")\n  // eg: mts.series(\"hostname.com/hits\")\n  series(name) {\n    var head, parts;\n    if (name[0] === \"/\") {\n      return this.series(name.substr(1));\n    }\n    if (name.indexOf(\"/\") > 0) {\n      parts = name.split(\"/\");\n      head = parts.shift();\n      if (!this.lookup[head]) {\n        return null;\n      }\n      return this.lookup[head].series(parts.join(\"/\"));\n    }\n    // base case...\n    if (!this.lookup[name]) {\n      return null;\n    }\n    return this.lookup[name];\n  }\n\n  get(name) {\n    return this.series(name);\n  }\n\n  limit(duration) {\n    var name, ref, results, ts;\n    super.limit(duration);\n    ref = this.lookup;\n    results = [];\n    for (name in ref) {\n      ts = ref[name];\n      results.push(ts.limit(duration));\n    }\n    return results;\n  }\n\n  append(t, v) {\n    var key, value;\n    for (key in v) {\n      value = v[key];\n      if (this.lookup.hasOwnProperty(key)) {\n        this.lookup[key].append(t, value);\n      } else {\n        this.lookup[key] = factory.build([[t, value]]);\n        this.attrs.push(key);\n      }\n    }\n    return super.append(t, v);\n  }\n\n  attr(name) {\n    return this.series(name);\n  }\n\n  serieses() {\n    return this.attrs;\n  }\n\n  // minimum of value\n  min() {\n    var key, mins, ref, series;\n    mins = [];\n    ref = this.lookup;\n    for (key in ref) {\n      series = ref[key];\n      if (series.min) {\n        mins.push(series.min());\n      }\n    }\n    return Math.min.apply(Math, mins);\n  }\n\n  // maximum of values\n  max() {\n    var key, maxes, ref, series;\n    maxes = [];\n    ref = this.lookup;\n    for (key in ref) {\n      series = ref[key];\n      if (series.max) {\n        maxes.push(series.max());\n      }\n    }\n    return Math.max.apply(Math, maxes);\n  }\n\n  // determine if a series exists by name\n  exists(name) {\n    return this.series(name) !== null;\n  }\n\n};\n\nexport default factory;\n"],
  "mappings": "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",
  "names": ["TimeseriesFactory", "Timeseries", "NumericTimeseries", "MultiTimeseries"]
}
